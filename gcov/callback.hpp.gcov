        -:    0:Source:/usr/include/boost/test/utils/callback.hpp
        -:    0:Graph:test-cases.gcno
        -:    0:Data:test-cases.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1://  (C) Copyright Gennadiy Rozental 2005-2008.
        -:    2://  Use, modification, and distribution are subject to the 
        -:    3://  Boost Software License, Version 1.0. (See accompanying file 
        -:    4://  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    5:
        -:    6://  See http://www.boost.org/libs/test for the library home page.
        -:    7://
        -:    8://  File        : $RCSfile$
        -:    9://
        -:   10://  Version     : $Revision$
        -:   11://
        -:   12://  Description : 
        -:   13:// ***************************************************************************
        -:   14:
        -:   15:#ifndef BOOST_TEST_CALLBACK_020505GER
        -:   16:#define BOOST_TEST_CALLBACK_020505GER
        -:   17:
        -:   18:// Boost
        -:   19:#include <boost/config.hpp>
        -:   20:#include <boost/detail/workaround.hpp>
        -:   21:#include <boost/shared_ptr.hpp>
        -:   22:
        -:   23:#include <boost/test/detail/suppress_warnings.hpp>
        -:   24:
        -:   25:#if BOOST_WORKAROUND(BOOST_MSVC, < 1300) || BOOST_WORKAROUND(BOOST_INTEL, <= 700)
        -:   26:#  define BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:   27:#endif
        -:   28:
        -:   29://____________________________________________________________________________//
        -:   30:
        -:   31:namespace boost {
        -:   32:
        -:   33:namespace unit_test {
        -:   34:
        -:   35:namespace ut_detail {
        -:   36:
        -:   37:struct unused {};
        -:   38:
        -:   39:template<typename R>
        -:   40:struct invoker {
        -:   41:    template<typename Functor>
        -:   42:    R       invoke( Functor& f )                        { return f(); }
        -:   43:    template<typename Functor, typename T1>
        -:   44:    R       invoke( Functor& f, T1 t1 )                 { return f( t1 ); }
        -:   45:    template<typename Functor, typename T1, typename T2>
        -:   46:    R       invoke( Functor& f, T1 t1, T2 t2 )          { return f( t1, t2 ); }
        -:   47:    template<typename Functor, typename T1, typename T2, typename T3>
        -:   48:    R       invoke( Functor& f, T1 t1, T2 t2, T3 t3 )   { return f( t1, t2, t3 ); }
        -:   49:};
        -:   50:
        -:   51://____________________________________________________________________________//
        -:   52:
        -:   53:template<>
        -:   54:struct invoker<unused> {
        -:   55:    template<typename Functor>
        8:   56:    unused  invoke( Functor& f )                        { f(); return unused(); }
        -:   57:    template<typename Functor, typename T1>
        -:   58:    unused  invoke( Functor& f, T1 t1 )                 { f( t1 ); return unused(); }
        -:   59:    template<typename Functor, typename T1, typename T2>
        -:   60:    unused  invoke( Functor& f, T1 t1, T2 t2 )          { f( t1, t2 ); return unused(); }
        -:   61:    template<typename Functor, typename T1, typename T2, typename T3>
        -:   62:    unused  invoke( Functor& f, T1 t1, T2 t2, T3 t3 )   { f( t1, t2, t3 ); return unused(); }
        -:   63:};
        -:   64:
        -:   65://____________________________________________________________________________//
        -:   66:
        -:   67:} // namespace ut_detail
        -:   68:
        -:   69:// ************************************************************************** //
        -:   70:// **************             unit_test::callback0             ************** //
        -:   71:// ************************************************************************** //
        -:   72:
        -:   73:namespace ut_detail {
        -:   74:
        -:   75:template<typename R>
        8:   76:struct callback0_impl {
    #####:   77:    virtual ~callback0_impl() {}
        -:   78:
        -:   79:    virtual R invoke() = 0;
        -:   80:};
        -:   81:
        -:   82://____________________________________________________________________________//
        -:   83:
        -:   84:template<typename R, typename Functor>
    #####:   85:struct callback0_impl_t : callback0_impl<R> {
        -:   86:    // Constructor
        8:   87:    explicit callback0_impl_t( Functor f ) : m_f( f ) {}
        -:   88:
        8:   89:    virtual R invoke() { return invoker<R>().invoke( m_f ); }
        -:   90:
        -:   91:private:
        -:   92:    // Data members
        -:   93:    Functor m_f;
        -:   94:};
        -:   95:
        -:   96://____________________________________________________________________________//
        -:   97:
        -:   98:} // namespace ut_detail
        -:   99:
        -:  100:template<typename R = ut_detail::unused>
        8:  101:class callback0 {
        -:  102:public:
        -:  103:    // Constructors
        -:  104:    callback0() {}
        -:  105:#ifdef BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:  106:    callback0( callback0 const& rhs ) : m_impl( rhs.m_impl ) {}
        -:  107:#endif
        -:  108:
        -:  109:    template<typename Functor>
        8:  110:    callback0( Functor f )
        8:  111:    : m_impl( new ut_detail::callback0_impl_t<R,Functor>( f ) ) {}
        -:  112:    
        -:  113:    void        operator=( callback0 const& rhs ) { m_impl = rhs.m_impl; }
        -:  114:
        -:  115:    template<typename Functor>
        -:  116:    void        operator=( Functor f ) { m_impl.reset( new ut_detail::callback0_impl_t<R,Functor>( f ) );  }
        -:  117:
        -:  118:    R           operator()() const { return m_impl->invoke(); }
        -:  119:
        -:  120:    bool        operator!() const { return !m_impl; }
        -:  121:
        -:  122:private:
        -:  123:    // Data members
        -:  124:    boost::shared_ptr<ut_detail::callback0_impl<R> > m_impl;
        -:  125:};
        -:  126:
        -:  127:// ************************************************************************** //
        -:  128:// **************             unit_test::callback1             ************** //
        -:  129:// ************************************************************************** //
        -:  130:
        -:  131:namespace ut_detail {
        -:  132:
        -:  133:template<typename R, typename T1>
        -:  134:struct callback1_impl {
        -:  135:    virtual ~callback1_impl() {}
        -:  136:
        -:  137:    virtual R invoke( T1 t1 ) = 0;
        -:  138:};
        -:  139:
        -:  140://____________________________________________________________________________//
        -:  141:
        -:  142:template<typename R, typename T1,typename Functor>
        -:  143:struct callback1_impl_t : callback1_impl<R,T1> {
        -:  144:    // Constructor
        -:  145:    explicit callback1_impl_t( Functor f ) : m_f( f ) {}
        -:  146:
        -:  147:    virtual R invoke( T1 t1 ) { return invoker<R>().invoke( m_f, t1 ); }
        -:  148:
        -:  149:private:
        -:  150:    // Data members
        -:  151:    Functor m_f;
        -:  152:};
        -:  153:
        -:  154://____________________________________________________________________________//
        -:  155:
        -:  156:} // namespace ut_detail
        -:  157:
        -:  158:template<typename T1,typename R = ut_detail::unused>
        -:  159:class callback1 {
        -:  160:public:
        -:  161:    // Constructors
        -:  162:    callback1() {}
        -:  163:#ifdef BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:  164:    callback1( callback1 const& rhs ) : m_impl( rhs.m_impl ) {}
        -:  165:#endif
        -:  166:
        -:  167:    template<typename Functor>
        -:  168:    callback1( Functor f )
        -:  169:    : m_impl( new ut_detail::callback1_impl_t<R,T1,Functor>( f ) ) {}
        -:  170:
        -:  171:    void        operator=( callback1 const& rhs ) { m_impl = rhs.m_impl; }
        -:  172:
        -:  173:    template<typename Functor>
        -:  174:    void        operator=( Functor f ) { m_impl.reset( new ut_detail::callback1_impl_t<R,T1,Functor>( f ) );  }
        -:  175:
        -:  176:    R           operator()( T1 t1 ) const { return m_impl->invoke( t1 ); }
        -:  177:
        -:  178:    bool        operator!() const { return !m_impl; }
        -:  179:
        -:  180:private:
        -:  181:    // Data members
        -:  182:    boost::shared_ptr<ut_detail::callback1_impl<R,T1> > m_impl;
        -:  183:};
        -:  184:
        -:  185:// ************************************************************************** //
        -:  186:// **************             unit_test::callback2             ************** //
        -:  187:// ************************************************************************** //
        -:  188:
        -:  189:namespace ut_detail {
        -:  190:
        -:  191:template<typename R, typename T1,typename T2>
        -:  192:struct callback2_impl {
        -:  193:    virtual ~callback2_impl() {}
        -:  194:
        -:  195:    virtual R invoke( T1 t1, T2 t2 ) = 0;
        -:  196:};
        -:  197:
        -:  198://____________________________________________________________________________//
        -:  199:
        -:  200:template<typename R, typename T1, typename T2, typename Functor>
        -:  201:struct callback2_impl_t : callback2_impl<R,T1,T2> {
        -:  202:    // Constructor
        -:  203:    explicit callback2_impl_t( Functor f ) : m_f( f ) {}
        -:  204:
        -:  205:    virtual R invoke( T1 t1, T2 t2 ) { return invoker<R>().template invoke<Functor,T1,T2>( m_f, t1, t2 ); }
        -:  206:
        -:  207:private:
        -:  208:    // Data members
        -:  209:    Functor m_f;
        -:  210:};
        -:  211:
        -:  212://____________________________________________________________________________//
        -:  213:
        -:  214:} // namespace ut_detail
        -:  215:
        -:  216:template<typename T1,typename T2, typename R = ut_detail::unused>
        -:  217:class callback2 {
        -:  218:public:
        -:  219:    // Constructors
        -:  220:    callback2() {}
        -:  221:#ifdef BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:  222:    callback2( callback2 const& rhs ) : m_impl( rhs.m_impl ) {}
        -:  223:#endif
        -:  224:
        -:  225:    template<typename Functor>
        -:  226:                callback2( Functor f ) : m_impl( new ut_detail::callback2_impl_t<R,T1,T2,Functor>( f ) ) {}
        -:  227:
        -:  228:    void        operator=( callback2 const& rhs ) { m_impl = rhs.m_impl; }
        -:  229:
        -:  230:    template<typename Functor>
        -:  231:    void        operator=( Functor f ) { m_impl.reset( new ut_detail::callback2_impl_t<R,T1,T2,Functor>( f ) );  }
        -:  232:
        -:  233:    R           operator()( T1 t1, T2 t2 ) const { return m_impl->invoke( t1, t2 ); }
        -:  234:
        -:  235:    bool        operator!() const { return !m_impl; }
        -:  236:
        -:  237:private:
        -:  238:    // Data members
        -:  239:    boost::shared_ptr<ut_detail::callback2_impl<R,T1,T2> > m_impl;
        -:  240:};
        -:  241:
        -:  242:// ************************************************************************** //
        -:  243:// **************             unit_test::callback3             ************** //
        -:  244:// ************************************************************************** //
        -:  245:
        -:  246:namespace ut_detail {
        -:  247:
        -:  248:template<typename R, typename T1, typename T2, typename T3>
        -:  249:struct callback3_impl {
        -:  250:    virtual ~callback3_impl() {}
        -:  251:
        -:  252:    virtual R invoke( T1 t1, T2 t2, T3 t3 ) = 0;
        -:  253:};
        -:  254:
        -:  255://____________________________________________________________________________//
        -:  256:
        -:  257:template<typename R, typename T1, typename T2, typename T3, typename Functor>
        -:  258:struct callback3_impl_t : callback3_impl<R,T1,T2,T3> {
        -:  259:    // Constructor
        -:  260:    explicit callback3_impl_t( Functor f ) : m_f( f ) {}
        -:  261:
        -:  262:    virtual R invoke( T1 t1, T2 t2, T3 t3 ) { return invoker<R>().invoke( m_f, t1, t2, t3 ); }
        -:  263:
        -:  264:private:
        -:  265:    // Data members
        -:  266:    Functor m_f;
        -:  267:};
        -:  268:
        -:  269://____________________________________________________________________________//
        -:  270:
        -:  271:} // namespace ut_detail
        -:  272:
        -:  273:template<typename T1,typename T2, typename T3, typename R = ut_detail::unused>
        -:  274:class callback3 {
        -:  275:public:
        -:  276:    // Constructors
        -:  277:    callback3() {}
        -:  278:#ifdef BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:  279:    callback3( callback3 const& rhs ) : m_impl( rhs.m_impl ) {}
        -:  280:#endif
        -:  281:
        -:  282:    template<typename Functor>
        -:  283:    callback3( Functor f )
        -:  284:    : m_impl( new ut_detail::callback3_impl_t<R,T1,T2,T3,Functor>( f ) ) {}
        -:  285:
        -:  286:    void        operator=( callback3 const& rhs ) { m_impl = rhs.m_impl; }
        -:  287:
        -:  288:    template<typename Functor>
        -:  289:    void        operator=( Functor f ) { m_impl.reset( new ut_detail::callback3_impl_t<R,T1,T2,T3,Functor>( f ) );  }
        -:  290:
        -:  291:    R           operator()( T1 t1, T2 t2, T3 t3 ) const { return m_impl->invoke( t1, t2, t3 ); }
        -:  292:
        -:  293:    bool        operator!() const { return !m_impl; }
        -:  294:
        -:  295:private:
        -:  296:    // Data members
        -:  297:    boost::shared_ptr<ut_detail::callback3_impl<R,T1,T2,T3> > m_impl;
        -:  298:};
        -:  299:
        -:  300:} // namespace unit_test
        -:  301:
        -:  302:} // namespace boost
        -:  303:
        -:  304:#undef BOOST_CALLBACK_EXPLICIT_COPY_CONSTRUCTOR
        -:  305:
        -:  306://____________________________________________________________________________//
        -:  307:
        -:  308:#include <boost/test/detail/enable_warnings.hpp>
        -:  309:
        -:  310:#endif // BOOST_TEST_CALLBACK_020505GER
